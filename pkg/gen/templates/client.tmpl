// Code generated by oapix-gen. DO NOT EDIT.
package {{.Package}}

import (
{{range .Imports}}	"{{.}}"
{{end}})

// {{.ClientName}} is the client for the API
type {{.ClientName}} struct {
	client.Client
}

// New{{.ClientName}} creates a new API client
func New{{.ClientName}}(config *client.Config) (*{{.ClientName}}, error) {
	baseClient, err := client.NewBaseClient(config)
	if err != nil {
		return nil, err
	}

	return &{{.ClientName}}{
		Client: baseClient,
	}, nil
}

{{range $op := .Operations}}
// {{$op.Name}} performs a {{$op.Method}} request to {{$op.Path}}
{{if $op.Summary}}// {{$op.Summary}}
{{end}}{{if $op.Description}}{{goDoc $op.Description ""}}
{{end}}{{if $op.Responses}}//
// Possible responses:
{{range $code, $resp := $op.Responses}}//   - {{$code}}: {{if $resp.Description}}{{$resp.Description}}{{else}}{{$code}} response{{end}}{{if $resp.Type}} ({{$resp.Type}}){{end}}
{{end}}{{end}}{{if $op.HasMultipleSuccessResponses}}//
// This endpoint returns different response types for different success status codes.
// Use the response wrapper methods to access the specific response type:
{{range $code, $resp := $op.Responses}}{{if and (startsWith $code "2") $resp.Type}}//   resp.As{{$code}}() - returns *{{$resp.Type}}
{{end}}{{end}}{{end}}func (c *{{$.ClientName}}) {{$op.Name}}({{buildMethodSignature $op}}) (*client.MultiResponse, error) {
	path := {{buildPathWithNamedParams $op.Path $op.Parameters}}

{{if or (hasQueryParams $op.Parameters) (hasHeaderParams $op.Parameters)}}
	opts := []client.RequestOption{}
{{if hasQueryParams $op.Parameters}}
	// Add query parameters
{{range filterParamsByIn $op.Parameters "query"}}
	if params != nil {
		opts = append(opts, client.WithQueryParam("{{.Name}}", fmt.Sprintf("%v", params.{{toPascalCase .Name}})))
	}
{{end}}
{{end}}
{{if hasHeaderParams $op.Parameters}}
	// Add header parameters
{{range filterParamsByIn $op.Parameters "header"}}
	if params != nil && params.{{toPascalCase .Name}} != "" {
		opts = append(opts, client.WithHeader("{{.Name}}", params.{{toPascalCase .Name}}))
	}
{{end}}
{{end}}
{{end}}

{{if $op.RequestBody}}
	resp, err := c.RequestJSON(ctx, "{{$op.Method}}", path, req{{if or (hasQueryParams $op.Parameters) (hasHeaderParams $op.Parameters)}}, opts...{{end}})
{{else}}
	resp, err := c.Request(ctx, "{{$op.Method}}", path, nil{{if or (hasQueryParams $op.Parameters) (hasHeaderParams $op.Parameters)}}, opts...{{end}})
{{end}}
	if err != nil {
		return nil, err
	}

	return &client.MultiResponse{Response: *resp}, nil
}

{{if or (hasQueryParams $op.Parameters) (hasHeaderParams $op.Parameters)}}
// {{$op.Name}}Params contains optional parameters for {{$op.Name}}
type {{$op.Name}}Params struct {
{{range $op.Parameters}}
{{if or (eq .In "query") (eq .In "header")}}
{{if .Description}}{{goDoc .Description "\t"}}{{end}}
	{{toPascalCase .Name}} {{.Type}}
{{end}}
{{end}}
}
{{end}}

{{if $op.HasMultipleSuccessResponses}}
// {{$op.Name}}ResponseWrapper provides type-safe access to different response types
type {{$op.Name}}ResponseWrapper struct {
	*client.MultiResponse
}

{{range $code, $resp := $op.Responses}}
{{if and (startsWith $code "2") $resp.Type}}
// As{{$code}} returns the response as {{$resp.Type}} for status {{$code}}
func (r *{{$op.Name}}ResponseWrapper) As{{$code}}() (*{{$resp.Type}}, error) {
	if !r.Is({{$code}}) {
		return nil, fmt.Errorf("expected status {{$code}}, got %d", r.StatusCode)
	}
	var result {{$resp.Type}}
	if err := r.As(&result); err != nil {
		return nil, err
	}
	return &result, nil
}
{{end}}
{{end}}

// Wrap{{$op.Name}}Response wraps a MultiResponse as {{$op.Name}}ResponseWrapper
func Wrap{{$op.Name}}Response(resp *client.MultiResponse) *{{$op.Name}}ResponseWrapper {
	return &{{$op.Name}}ResponseWrapper{MultiResponse: resp}
}
{{end}}
{{end}}