package main

import (
	"context"
	"fmt"
	"log"

	"github.com/jmcarbo/oapix/pkg/client"
)

// This example demonstrates how to use the multi-response feature
// when an API can return different response types for different status codes

func main() {
	// Create a client configuration
	config := &client.Config{
		BaseURL: "https://api.example.com",
	}

	// Create the API client (this would be generated by oapix-gen)
	apiClient, err := NewAPIClient(config)
	if err != nil {
		log.Fatal(err)
	}

	ctx := context.Background()

	// Example 1: Handle multiple success responses (200 vs 201)
	fmt.Println("=== Example 1: Create Asset ===")
	handleCreateAsset(ctx, apiClient)

	// Example 2: Handle success and error responses
	fmt.Println("\n=== Example 2: Get User ===")
	handleGetUser(ctx, apiClient)

	// Example 3: Using type-safe response helpers (when generated)
	fmt.Println("\n=== Example 3: Type-safe helpers ===")
	handleWithTypeSafeHelpers(ctx, apiClient)
}

func handleCreateAsset(ctx context.Context, client *APIClient) {
	assetInput := AssetInput{
		Name: "My Asset",
		Type: "document",
	}

	// The method returns a MultiResponse
	resp, err := client.CreateAsset(ctx, "asset123", assetInput)
	if err != nil {
		// Network or request building errors
		log.Printf("Request failed: %v", err)
		return
	}

	// Check the status code to determine what happened
	switch resp.StatusCode {
	case 200:
		// Asset was updated
		var asset ContentNodeTransport
		if err := resp.As(&asset); err != nil {
			log.Printf("Failed to parse updated asset: %v", err)
			return
		}
		fmt.Printf("Asset updated: ID=%s, Name=%s\n", asset.ID, asset.Name)

	case 201:
		// Asset was created
		var asset ContentNodeTransport
		if err := resp.As(&asset); err != nil {
			log.Printf("Failed to parse created asset: %v", err)
			return
		}
		fmt.Printf("Asset created: ID=%s, Name=%s\n", asset.ID, asset.Name)

	case 204:
		// No content response
		fmt.Println("Operation completed successfully (no content)")

	case 400:
		// Bad request
		var badRequest FrontendHandledBackendError
		if err := resp.As(&badRequest); err != nil {
			log.Printf("Failed to parse error: %v", err)
			return
		}
		fmt.Printf("Bad request: %s (code: %s)\n", badRequest.Error, badRequest.Code)

	case 403:
		// Forbidden - no response body
		fmt.Println("Access forbidden")

	case 500:
		// Internal server error
		var serverError ExceptionReference
		if err := resp.As(&serverError); err != nil {
			log.Printf("Failed to parse server error: %v", err)
			return
		}
		fmt.Printf("Server error: %s (ref: %s)\n", serverError.Message, serverError.Reference)

	default:
		fmt.Printf("Unexpected status code: %d\n", resp.StatusCode)
	}
}

func handleGetUser(ctx context.Context, client *APIClient) {
	resp, err := client.GetUser(ctx, "user123")
	if err != nil {
		log.Printf("Request failed: %v", err)
		return
	}

	// Use helper methods for common checks
	if resp.IsSuccess() {
		var user User
		if err := resp.As(&user); err != nil {
			log.Printf("Failed to parse user: %v", err)
			return
		}
		fmt.Printf("User found: %s <%s>\n", user.Name, user.Email)
	} else if resp.Is(404) {
		var notFound NotFoundError
		if err := resp.As(&notFound); err != nil {
			log.Printf("Failed to parse not found error: %v", err)
			return
		}
		fmt.Printf("User not found: %s\n", notFound.Message)
	} else if resp.IsError() {
		// Handle any other error
		fmt.Printf("Error response: %d\n", resp.StatusCode)
	}
}

func handleWithTypeSafeHelpers(ctx context.Context, client *APIClient) {
	// When HasMultipleSuccessResponses is true, the generator creates
	// type-safe helper methods for each response type

	resp, err := client.CreateAsset(ctx, "asset456", AssetInput{
		Name: "Another Asset",
		Type: "image",
	})
	if err != nil {
		log.Printf("Request failed: %v", err)
		return
	}

	// Wrap the response with type-safe helpers
	assetResp := WrapCreateAssetResponse(resp)

	// Now you can use type-safe methods
	if assetResp.Is(200) {
		asset, err := assetResp.As200() // Returns *ContentNodeTransport
		if err != nil {
			log.Printf("Failed to get asset: %v", err)
			return
		}
		fmt.Printf("Asset updated with type-safe helper: %s\n", asset.Name)
	} else if assetResp.Is(201) {
		asset, err := assetResp.As201() // Returns *ContentNodeTransport
		if err != nil {
			log.Printf("Failed to get asset: %v", err)
			return
		}
		fmt.Printf("Asset created with type-safe helper: %s\n", asset.Name)
	}
}

// The following types would be generated by oapix-gen from the OpenAPI spec

type APIClient struct {
	client.Client
}

func NewAPIClient(config *client.Config) (*APIClient, error) {
	baseClient, err := client.NewBaseClient(config)
	if err != nil {
		return nil, err
	}
	return &APIClient{Client: baseClient}, nil
}

// These method signatures demonstrate what oapix-gen would generate
func (c *APIClient) CreateAsset(ctx context.Context, assetId string, req AssetInput) (*client.MultiResponse, error) {
	// Implementation would be generated
	return nil, nil
}

func (c *APIClient) GetUser(ctx context.Context, userId string) (*client.MultiResponse, error) {
	// Implementation would be generated
	return nil, nil
}

// Type-safe response wrapper (generated when HasMultipleSuccessResponses is true)
type CreateAssetResponseWrapper struct {
	*client.MultiResponse
}

func (r *CreateAssetResponseWrapper) As200() (*ContentNodeTransport, error) {
	if !r.Is(200) {
		return nil, fmt.Errorf("expected status 200, got %d", r.StatusCode)
	}
	var result ContentNodeTransport
	if err := r.As(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

func (r *CreateAssetResponseWrapper) As201() (*ContentNodeTransport, error) {
	if !r.Is(201) {
		return nil, fmt.Errorf("expected status 201, got %d", r.StatusCode)
	}
	var result ContentNodeTransport
	if err := r.As(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

func WrapCreateAssetResponse(resp *client.MultiResponse) *CreateAssetResponseWrapper {
	return &CreateAssetResponseWrapper{MultiResponse: resp}
}

// Model types (would be generated from OpenAPI spec)
type AssetInput struct {
	Name     string                 `json:"name"`
	Type     string                 `json:"type"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

type ContentNodeTransport struct {
	ID        string                 `json:"id,omitempty"`
	Name      string                 `json:"name,omitempty"`
	Type      string                 `json:"type,omitempty"`
	CreatedAt string                 `json:"createdAt,omitempty"`
	UpdatedAt string                 `json:"updatedAt,omitempty"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

type User struct {
	ID     string `json:"id,omitempty"`
	Email  string `json:"email,omitempty"`
	Name   string `json:"name,omitempty"`
	Active bool   `json:"active,omitempty"`
}

type FrontendHandledBackendError struct {
	Error   string                 `json:"error,omitempty"`
	Code    string                 `json:"code,omitempty"`
	Details map[string]interface{} `json:"details,omitempty"`
}

type NotFoundError struct {
	Message  string `json:"message,omitempty"`
	Resource string `json:"resource,omitempty"`
	ID       string `json:"id,omitempty"`
}

type ExceptionReference struct {
	Reference string `json:"reference,omitempty"`
	Message   string `json:"message,omitempty"`
	Timestamp string `json:"timestamp,omitempty"`
}
